

=========================SQL 介绍================================

DDL、DML等等


===================数据库操作==================================

创建数据库
create database 数据库名 【选项】
选项：
	charset
	collate

eg: create database mydb charset utf8;


显示数据库：
	show databases like '%my%';

选择数据库： use mydb;

修改数据库；
	v5.5后不能修改数据库名字
alter database mytestdb charset gbk;

删除数据库： drop database 数据库名

=====================数据表操作==================
创建表： create table 表明(字段名 字段类型 [字段属性], 字段名 字段类型 [字段属性]) 【表选项】

显示结构三种方式
	desc 表名
	describe 表名
	show columns from 表名 


修改表选项
	alter table student charset gbk;

修改表名：  rename table 旧表名 to 新表名

修改字段名： alter table 表名 change 就字段名 新字段名 【新属性】 【新位置】

修改字段属性与类型： alter table 表名 modify 字段名 新类型 [新属性] 【新位置】 
ps:change与modify 的区别前者可以用来修改字段名。（他们都会把字段原有属性丢失，主键除外）

==================================数据操作==============================


插入数据： insert into 表名 values (对应表结构)


================================数据库字符集===================
查看数据库字符集
show variables like 'character_set%';

set names utf8; //修改character_set_client、character_set_connection、character_set_results 为utf8

set character_set_results=gbk; //单独设置某个字符集


========================================================================================

==============数据类型（专门一片博客）==================
整型：默认有符号，类型后面加 unsigned，声明为无符号
eg:alter table student add column id int unsigned first;
整型字段声明zerofill属性，表示在指定长度内左填充0。

数据库时间类型：
如果为timestamp类型，默认属性为 not null, 当数据更新时，这个字段自动更新为当前最新时间，ps:起始时间为格林威治时间1970？？？
year类型有个临界点，69/70


字符串类型：
char一定会使用指定的空间，varchar是根据数据来定空间的
char的数据查询效率比varchar高，varchar需要通过后面得记录数据来计算
ps:varchar类型实际长度要比指定长度多出1(长度127一下)或2(长度127以上)个字节，因为需要记录长度信息
ps：如果长度超过255，最好使用text类型

===================字段属性==============================
字段属性（共6个）：null，默认值，列描述，主键，唯一，自动增长

自动增长属性必须用于主键且是整型



====================高级操作================================
新增数据：
	主键冲突更新：insert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段名 = 新值;
	主键冲突替换(删除原来数据，新增一条数据)：replace into 表名 [(字段列表)] values(值列表); 

	蠕虫复制： 一分为二，成倍增加。从已有的数据中获取数据，并且将获取到的数据插入数据表中。
		基本语法：insert into 表名 [(字段列表)] select */字段列表 from 表名；
		ps:蠕虫复制通常是重复的数据，没有太大的业务意义，可以在短期内快速增加表的数据量，从而可以测试表的压力，还可以通过大量数据来测试表的效率（索引）。 蠕虫复制虽好，但要注意主键冲突。

删除所有数据并重置自增长： truncate 表名；


====================高级操作-查询============================

完整的查询指令： select select选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制；

select选项：系统该如何对待查询得到的结果；
	all:默认的，表示保存所有的记录
	distinct:去重，去除重复的记录，只保留一条

字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名的，别名 alias
	基本语法：字段名 [as] 别名


from数据源：from是为前面的查询提供数据，数据源只要是一个符合二维表结构的数据即可。
	单表数据源：from 表名
	多表数据源：from 表1，表2...
		查询结果：两张表的记录数相乘，字段数拼接
		本质：从第一张表取出一条记录，去拼凑第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的说法：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义，应该尽量避免出现笛卡尔积
	动态数据源：from后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。
		基本语法：from (select 字段列表 from 表) [as] 别名

where字句：用来从数据表获取数据的时候，然后进行条件筛选。
	数据获取原理：针对表去对应的磁盘获取所有的记录（一条条获取），where的作用就是在拿到一条条结果就开始进行判断，判断是否符合条件，如果符合就保存下来，如果不符合直接舍弃（不放到内存中）。where是通过运算符进行结果比较来判断数据。


group by子句：group by表示分组的含义，根据指定的字段，将数据进行分组，分组的目标是为了统计
	分组统计：
		基本语法：group by 字段名；
		group by 是为了分组后进行数据统计的，如果只是想看数据显示，那么group by没什么含义，group by经数据按照指定的字段分组之后，只会保留每组的第一条记录。
		利用一些统计函数：	
			count(): 统计每组中的数量，如果统计目标是字段，那么不统计为NULL字段
			avg()：求平均值
			sum(): 求和
			max(): 求最大值
			min(): 求最小值
			group_concat(): 为了将分组中指定的字段进行合并（字符串拼接）
	多分组：group by 字段1，字段2 //按照字段1进行分组后，再按照字段2进行分组，以此类推
	分组排序：mysql中，分组默认有排序的功能，按照分组字段进行排序，默认是升序
		基本语法：group by 字段 [asc|desc], 字段 [asc|desc]		

	回溯统计：当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计，每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL
		基本语法：group by 字段 [asc|desc] with rollup

 having子句
 	having的本质和where一样，是用来进行数据条件筛选。
 	1、having是在group by子句之后，可以针对分组数据进行统计筛选，但是where不行。
 	2、where不能使用聚合函数，聚合函数是用在group by分组的时候where已经运行完毕了，having在group by分组之后，可以使用聚合函数或者字段别名（where是从表中取数据，别名是在数据进入到内存之后才有的）
 	ps:having是在group by之后，group by是在where之后，where的时候表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作。

 order by排序：根据校对规则对数据进行排序
 	基本语法: order by 字段 [asc|desc] //asc升序，默认；desc降序
 	多字段排序：order by 字段1 [asc|desc], 字段2 [asc|desc]

 limit子句
 	limit限制子句，主要是用来限制记录数量获取
 	记录数限制：	
 		纯粹的限制获取的数量，从第一条到指定的数量
 		基本语法：limit 数量;
 		ps:limit通常在查询的时候如果限定为一条记录的时候，使用的比较多，有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力
 	分页：
 		利用limit来限制获取指定区间的数据。
 		基本语法：limit offset, length; //offset 偏移量：从哪开始，length就是具体的获取多少条记录
 		mysql中记录数从0开始，eg:limit 0,2;表示获取前两条数据
 		ps:limit 后面的length表示最多获取对应数量，但是如果数量不够，系统不会强求

========================联合查询====================================

基本概念
	联合查询是可合并过个相似的选择查询结果集。等同意将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为 union

	联合查询：将多个查询的结果合并到一起（纵向合并）：字段数不变(可以为不同字段类型)，多个查询的记录数合并

	应用场景：
		1）将同一张表中不同的结果（需要对应多条查询语句来实现），合并到一起展示数据。
		2）最常见：在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合查询来将数据存放到一起显示

	基本语法： 	
		select语句 union [union选项] select语句;
		union选项：与select选项基本一样
		distinct:去重，去掉完全重复的数据（默认值）
		all:全部数据

	ps:
		1）union理论上只要保证字段数一样，不需要每次拿到的数据对应的字段类型不一样。永远只保留第一个select语句对应的字段名字。	
		2）在联合查询中，如果要使用order by, 那么对应的select语句必须使用括号括起来
		3）order by在联合查询中若要生效，必须配合使用limit（限制数通常可以使用一个较大的值，大于对应表的记录数）


======================连接查询=============================================================================
连接查询：将多张表连到一起进行查询（会导致记录行数和字段列数发生改变）
	
	连接查询的意义：在关系型数据库设计过程中，实体（表）与实体之间是存在很多联系的。在关系型数据库表的设计过程中，遵循着关系来设计，一对一，一对多和多对多，通常在实际操作的过程中需要利用这层关系来保证数据的完整性。

	连接查询分类：
		交叉连接
		内连接
		外连接：左连接和右连接
		自然连接

	交叉连接：将一张表的数据与另外一张表彼此交叉，本质与 “from 表1，表2” 相同 	
		原理：
			1）从第一张表一次取出每一条记录
			2）取出每一条记录之后，与另外一张表的全部记录挨个匹配
			3）如果没有任何匹配条件，所有的结果都会进行保留
			4）查询结果为笛卡尔积，记录数 = 第一张表记录数 * 第二张表记录数, 字段数 = 第一张表字段数 + 第二张表字段数

		基本语法：表1 cross join	表2

		应用：交叉连接产生的结果是笛卡尔积，没有实际价值，尽量不要使用交叉连接

	内连接


=========================SQL 介绍================================

DDL、DML等等


===================数据库操作==================================

创建数据库
create database 数据库名 【选项】
选项：
	charset
	collate

eg: create database mydb charset utf8;


显示数据库：
	show databases like '%my%';

选择数据库： use mydb;

修改数据库；
	v5.5后不能修改数据库名字
alter database mytestdb charset gbk;

删除数据库： drop database 数据库名

=====================数据表操作==================
创建表： create table 表明(字段名 字段类型 [字段属性], 字段名 字段类型 [字段属性]) 【表选项】

显示结构三种方式
	desc 表名
	describe 表名
	show columns from 表名 


修改表选项
	alter table student charset gbk;

修改表名：  rename table 旧表名 to 新表名

修改字段名： alter table 表名 change 就字段名 新字段名 【新属性】 【新位置】

修改字段属性与类型： alter table 表名 modify 字段名 新类型 [新属性] 【新位置】 
ps:change与modify 的区别前者可以用来修改字段名。（他们都会把字段原有属性丢失，主键除外）

==================================数据操作==============================


插入数据： insert into 表名 values (对应表结构)


================================数据库字符集===================
查看数据库字符集
show variables like 'character_set%';

set names utf8; //修改character_set_client、character_set_connection、character_set_results 为utf8

set character_set_results=gbk; //单独设置某个字符集


========================================================================================

==============数据类型（专门一片博客）==================
整型：默认有符号，类型后面加 unsigned，声明为无符号
eg:alter table student add column id int unsigned first;
整型字段声明zerofill属性，表示在指定长度内左填充0。

数据库时间类型：
如果为timestamp类型，默认属性为 not null, 当数据更新时，这个字段自动更新为当前最新时间，ps:起始时间为格林威治时间1970？？？
year类型有个临界点，69/70


字符串类型：
char一定会使用指定的空间，varchar是根据数据来定空间的
char的数据查询效率比varchar高，varchar需要通过后面得记录数据来计算
ps:varchar类型实际长度要比指定长度多出1(长度127一下)或2(长度127以上)个字节，因为需要记录长度信息
ps：如果长度超过255，最好使用text类型

===================字段属性==============================
字段属性（共6个）：null，默认值，列描述，主键，唯一，自动增长

自动增长属性必须用于主键且是整型



====================高级操作================================
新增数据：
	主键冲突更新：insert into 表名 [(字段列表)] values(值列表) on duplicate key update 字段名 = 新值;
	主键冲突替换(删除原来数据，新增一条数据)：replace into 表名 [(字段列表)] values(值列表); 

	蠕虫复制： 一分为二，成倍增加。从已有的数据中获取数据，并且将获取到的数据插入数据表中。
		基本语法：insert into 表名 [(字段列表)] select */字段列表 from 表名；
		ps:蠕虫复制通常是重复的数据，没有太大的业务意义，可以在短期内快速增加表的数据量，从而可以测试表的压力，还可以通过大量数据来测试表的效率（索引）。 蠕虫复制虽好，但要注意主键冲突。

删除所有数据并重置自增长： truncate 表名；


====================高级操作-查询============================

完整的查询指令： select select选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制；

select选项：系统该如何对待查询得到的结果；
	all:默认的，表示保存所有的记录
	distinct:去重，去除重复的记录，只保留一条

字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段命名成不同名的，别名 alias
	基本语法：字段名 [as] 别名


from数据源：from是为前面的查询提供数据，数据源只要是一个符合二维表结构的数据即可。
	单表数据源：from 表名
	多表数据源：from 表1，表2...
		查询结果：两张表的记录数相乘，字段数拼接
		本质：从第一张表取出一条记录，去拼凑第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的说法：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义，应该尽量避免出现笛卡尔积
	动态数据源：from后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。
		基本语法：from (select 字段列表 from 表) [as] 别名

where字句：用来从数据表获取数据的时候，然后进行条件筛选。
	数据获取原理：针对表去对应的磁盘获取所有的记录（一条条获取），where的作用就是在拿到一条条结果就开始进行判断，判断是否符合条件，如果符合就保存下来，如果不符合直接舍弃（不放到内存中）。where是通过运算符进行结果比较来判断数据。


group by子句：group by表示分组的含义，根据指定的字段，将数据进行分组，分组的目标是为了统计
	分组统计：
		基本语法：group by 字段名；
		group by 是为了分组后进行数据统计的，如果只是想看数据显示，那么group by没什么含义，group by经数据按照指定的字段分组之后，只会保留每组的第一条记录。
		利用一些统计函数：	
			count(): 统计每组中的数量，如果统计目标是字段，那么不统计为NULL字段
			avg()：求平均值
			sum(): 求和
			max(): 求最大值
			min(): 求最小值
			group_concat(): 为了将分组中指定的字段进行合并（字符串拼接）
	多分组：group by 字段1，字段2 //按照字段1进行分组后，再按照字段2进行分组，以此类推
	分组排序：mysql中，分组默认有排序的功能，按照分组字段进行排序，默认是升序
		基本语法：group by 字段 [asc|desc], 字段 [asc|desc]		

	回溯统计：当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称之为回溯统计，每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL
		基本语法：group by 字段 [asc|desc] with rollup

 having子句
 	having的本质和where一样，是用来进行数据条件筛选。
 	1、having是在group by子句之后，可以针对分组数据进行统计筛选，但是where不行。
 	2、where不能使用聚合函数，聚合函数是用在group by分组的时候where已经运行完毕了，having在group by分组之后，可以使用聚合函数或者字段别名（where是从表中取数据，别名是在数据进入到内存之后才有的）
 	ps:having是在group by之后，group by是在where之后，where的时候表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作。
